import React from 'react';
import { client } from '../../library/client';
import { useRouter } from 'next/router';
import Head from 'next/head';
import { AuthorSchema } from '../../model/author';
import { GetStaticPaths, GetStaticProps, NextPage, PreviewData } from 'next';
import { ParsedUrlQuery } from 'querystring';
import type {
  GetStaticPathsResult,
  GetStaticPropsContext,
  GetStaticPropsResult,
} from 'next';

const Author: NextPage<{ result: AuthorSchema[] }> = ({ result }) => {
  console.log(result);
  const router = useRouter();

  if (router.isFallback) {
    return <div>Loading</div>;
  } else {
    return (
      <div>
        <Head>
          <title>{result[0].name} | Author</title>
          <meta name='description' content='Generated by create next app' />
          <link rel='icon' href='/favicon.ico' />
        </Head>
      </div>
    );
  }
};

export default Author;

interface PropsPath {
  query_paths: {
    slug: {
      current: string;
    };
  };
}

interface AuthorParams extends ParsedUrlQuery {
  author: string;
}

export const getStaticPaths: GetStaticPaths = async () => {
  const query = `*[_type == "author"]{
  slug{
  current,
}
}`;

  const query_paths = await client.fetch(query);

  const paths = query_paths.map((path: PropsPath[]) => ({
    params: {
      author: path.slug.current,
    },
  }));

  return {
    paths,
    fallback: true,
  };
};

export const getStaticProps: GetStaticProps = async (context) => {
  const { author } = context.params as AuthorParams;
  const query = `*[_type == "author" && slug.current == "${author}"]{
  name,
  slug,
  "image": image.asset->url,
  bio,
  _id,
  "post": *[_type == "post" && author->._id == ^._id][]{
  author->{
    name,
    slug,
    "image": image.asset->url,
  },
  slug,
  "image": mainImage.asset->url,
  category->{
    name,
    slug,
  },
  body,
  title,
  featured_post,
  recommended_post,
  publishedAt,
}
}`;

  const result: AuthorSchema[] = await client.fetch(query);

  if (!result) {
    return {
      error: true,
      data: [],
    };
  } else {
    return {
      props: {
        result,
      },
      revalidate: 10,
    };
  }
};
